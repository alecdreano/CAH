

const config_css = {
	gapped: {
		front: 'gapped-card-front',
		back: 'gapped-card-back',
		content: 'gapped-card-content',
	}, 
	completion: {
		front: 'completion-card-front',
		back: 'completion-card-back',
		content: 'completion-card-content',
	},
	blank: 'blank-card',
};

function formatFrontCard(card) {
	let html_number_cards;
	let html_homemade;

	// SI CARTE A TROU AVEC NOMBRE DE TROU DIFFERENT DU NOMBRE DE CARTE A DONNER, ALORS IL FAUT UNE PRECISION SUPPLEMENTAIRE SUR LA CARTE
	if (card.type == "gapped") {
		
		if (card.details.is_implicite) {
			let gaps = card.details.gaps;
			gaps = 2;
			html_number_cards = `
			<div class="gapped-card-front-header-left">
				<img class="img-block" src="assets/images/cards/front/headers/gaps/${String(gaps)}.png">
			</div>
			`;
		}
	}
	let classes = config_css[card.type];
	html = `
		<div class="${classes.front}">
			<div class="gapped-card-front-header-container">
				${html_homemade || ''}
				${html_number_cards || ''}
			</div>
			<div class="front-content-container">
      			<div class="${classes.content}">
						${card.content}
				</div>
			</div>
		    <div class="img-container-front">
		        <img class ="img-block" src="assets/images/cards/front/footers/${card.type}/None/1.png">
		    </div>
		</div>
	`;
	return html;
}

function formatBackCard(card) {
	let classes = config_css[card.type];
	html = `
		<div class="${classes.back}">
			<div class="gapped-card-back-main-container">
				<img class ="img-block" src="assets/images/cards/back/central/background.png">
			</div>   
			<div class="gapped-card-back-footer-container">
				<img class ="img-block" src="assets/images/cards/back/footers/logo.png">
			</div>   
		</div>
	`
;
return html;
}

function formatBlankCard(card) {
	html = `<div class="${config_css.blank}"></div>`;
	return html;
}

function formatCardsHtml(json_cards) {
	let cards_html = {
		"completion": {
			"front": [],
			"back": [],
		},
		"gapped": {
			"front": [],
			"back": [],
		},
	}
	let html = '';
	// COMPLETION CARDS
	if (json_cards.gapped) {
		let gapped_cards = json_cards.gapped["1"].concat(json_cards.gapped["2"]).concat(json_cards.gapped["3"])
		for (let card of gapped_cards) {
			cards_html.gapped.front.push(formatFrontCard(card));
			cards_html.gapped.back.push(formatBackCard(card));
		}
	}
	if (json_cards.completion) {
		for (let card of json_cards.completion) {
			cards_html.completion.front.push(formatFrontCard(card));
			cards_html.completion.back.push(formatBackCard(card));
		}
	}
	return cards_html;
}

let print_config = {
	cards_by_page: 4,
};
function outputHtml(cards_html) {
	getPrintableHtml = function(cards) {
		let cbp = print_config.cards_by_page;
		let html = "";
		let html_cards_only;
		let html_pages = '';
		let len = Math.ceil(cards.front.length / cbp);
		len = 1;
		const reducer = (a,b) => a+b;
		let html_blank_cards;
		for (i = 0; i < len; i++) {
			if (i +1 == len) {
				let nb_of_blank_to_add = cbp - cards.front.slice(i*cbp,i*cbp+cbp).length;
				if (nb_of_blank_to_add > 0 ) {
					html_blank_cards = "";
					for (k = 0; k < nb_of_blank_to_add; k++) {
						html_blank_cards += formatBlankCard();
					}
				}
			}
			html_cards_only_front = cards.front.slice(i*cbp,i*cbp+cbp).reduce(reducer);
			html_pages += `
				<div class="page" size="A4">
					<div class="subpage">
						${html_cards_only_front}
					</div>
				</div>
			`;
			//if (html_blank_cards) {
			//	html += html_blank_cards;
			//}
			html_cards_only_back = cards.back.slice(i*cbp,i*cbp+cbp).reduce(reducer);
			html_pages += `
				<div class="page" size="A4">
					<div class="subpage">
						${html_cards_only_back}
					</div>
				</div>
			`;
			//html += 
			//if (html_blank_cards) {
			//	html += html_blank_cards;
			//}
		}
		return html_pages;
	}
	let html = getPrintableHtml(cards_html.gapped);
	html += getPrintableHtml(cards_html.completion);
	document.getElementById("deck").innerHTML = html;
}
function init() {
	if (json_cards) {
		cards_html = formatCardsHtml(json_cards);
		outputHtml(cards_html);
	}
}

init();
//window.print()

`
	TROUVER UN MOYEN DE METTRE UNE IMAGE EN ARRIERE PLAN D'UNE DIV
	PRINCIPE DE RECURRENCE: POSSIBILITE D AJOUTER PLUSIEURS FOIS LA MEME CARTE
	SUGGESTION: CARTE TEMPLATE A PROPOSER A L UTILISATEUR DIRECTEMENT POUR QU IL RAJOUTE UN PRENOM
	CARTE TROU: PYTHON: FAIRE REMONTER ELEMENT SI NOMBRE DE TROU DIFFERENTS DE NOMBRE DE SIGNE TROU
	CARTE TOU: JS: AFFICHER UNE ICONE INDIQUANT D UTILISER LE NOMBRE DE CARTE SI IMPLICITE
	CARTE TROU: CARRE 90 SUR 90
	CARTE COMPLETION: 3 ZONES POSSIBLES POUR LE TEXTE ET LES IMAGES (= 3 CSS)
	CARTE TROU: 3 ZONE POSSIBLES POUR LE TEXTE
	CHOIX DES ZONES: CATEGORIES ou HASARD
	CARTE BONUS: DIFFERENTE, CATEGORIE UNIQUE, A VOIR PLUS TARD
	IMPORTER UNE POLICE CSS A PARTIR D UN FICHIER LOCAL
	PLUS TARD: CODER UN FORMAT A3 SI NECESSAIRE
	CAECILIA LT STD HEAVY 85
	IDEE DE NOMS:
	GOODBYE BUDDY
`